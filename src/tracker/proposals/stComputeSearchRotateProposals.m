function [frmProposal, totalNoOfRotDetProp] = stComputeSearchRotateProposals( model, image, plattModel, ...
    prevBaseAngle, prevRegion, frmProposal, flags, searchScaleRange, ...
    noOfProp, prevMeanAngleConf, prevMeanDeltaAngle)
% Compute and return proposals obtained from rotated detections.
%
% INPUTS
%   model - an instance of TBDModel class
%   image - the current frame of the video
%   plattModel - an instance of PlattModel class
%   prevBaseAngle - rotation angle from previous result
%   prevRegion - bounding box region from the previous frame
%   frmProposal - structure containing data about the proposals of the
%                 current frame
%   flags - structure with binary valued flags
%   searchScaleRange - list of scale values to test
%   noOfProp - number of proposals already generated by other functions
%   prevMeanAngleConf - mean of previous angle confidences
%   prevMeanDeltaAngle - mean of previous angle changes
%
% OUTPUTS
%   frmProposal - updated structure containing data about the proposals of the
%                 current frame
%   totalNoOfRotDetProp - number of proposals generated by this step
%
% AUTHORS
%   Yang Hua (Yang.Hua@inria.fr)
%   Henrique Morimitsu (Henrique.Morimitsu@inria.fr)
%
% Licensed under the BSD 3-clause license [see license.txt]
%


    global VERBOSITY;
    
    angleRange = [prevMeanDeltaAngle prevMeanDeltaAngle+2.0 prevMeanDeltaAngle-2.0];

    noOfRotDetProp = 1;
    [imHeight, imWidth, ~] = size(image);

    if VERBOSITY > 1
        fprintf('Rotated proposals: angle range\n');
        disp(angleRange);
    end
    for i = 1:length(angleRange)
        kAngle = angleRange(i);

        currBaseAngle = prevBaseAngle - kAngle;

        rotIm = imrotate(image, -currBaseAngle, 'bicubic', 'loose'); 

        rotRegion = galRotateRegion(prevRegion, currBaseAngle, imWidth, imHeight, rotIm);

        %get rectangle from rotated ofht region from regular position / do dense nearby search
        [tempWidth, tempHeight] = model.getTemplateSize;
        [rotRect, ~] = galRegion2RectBFS(rotRegion, rotIm, tempWidth, tempHeight); 

        [detbb, ~] = model.det.detectOneFrmLocally(model, rotIm, ...
                     rotRect,  noOfRotDetProp, searchScaleRange);  
        if flags.USE_PLATT_MAPPING_FLAG
            detbb(:, 6) = plattModel.computePlattScaledScores(detbb(:, 5));
        else
            detbb(:, 6) = 0.0;
        end
        
        if VERBOSITY > 1
            fprintf('currBaseAngle: %0.03f\n', currBaseAngle);
            printRegionInfo(rotRegion, 'rotRegion');
        end

        detRegionRot = galRectXY2Region(detbb(:, 1:4));       

        %should rotate det back to region
        detRegion = zeros(noOfRotDetProp, 8);
        [rotHeight, rotWidth, ~] = size(rotIm);
        for kBB = noOfRotDetProp:-1:1
            detRegion(kBB, :) = galRotateRegion(detRegionRot(kBB, :), -currBaseAngle, rotWidth, rotHeight, image);
        end
        frmProposal = stAddFrmProposalData( frmProposal, noOfProp+i, noOfProp+(i-1)+noOfRotDetProp,...
            detbb, detRegion, repmat(currBaseAngle, noOfRotDetProp, 1),...
            repmat(prevMeanAngleConf, noOfRotDetProp, 1), {rotIm} );
 
    end % for kAngle = angleRange
        
    if VERBOSITY > 1
        fprintf('Rotated proposals');
        printRectInfo(frmProposal.detProp(noOfProp+i:noOfProp+(i-1)+noOfRotDetProp, :));
        printRegionInfo(frmProposal.regionProp(noOfProp+i:noOfProp+(i-1)+noOfRotDetProp, :));
    end

    totalNoOfRotDetProp = length(angleRange) * noOfRotDetProp;

end

